# Copyright 2025 Canonical Ltd.
# See LICENSE file for licensing details.

"""haproxy-operator charm tls information."""

import logging
import re
from dataclasses import dataclass

import ops
from charms.tls_certificates_interface.v4.tls_certificates import (
    Certificate,
    TLSCertificatesRequiresV4,
)

# RFC-1034 and RFC-2181 compliance REGEX for validating FQDNs
HOSTNAME_REGEX = (
    r"(?=.{1,253})(?!.*--.*)(?:(?!-)(?![0-9])[a-zA-Z0-9-]"
    r"{1,63}(?<!-)\.){1,}(?:(?!-)[a-zA-Z0-9-]{1,63}(?<!-))"
)

logger = logging.getLogger()


class TLSNotReadyError(Exception):
    """Exception raised when the charm is not ready to handle TLS."""


class PrivateKeyNotGeneratedError(Exception):
    """Exception raised when the private key has not been generated by the library."""


# pydantic dataclass is not used here as we already performed our validation logic
# in the validate method
@dataclass(frozen=True)
class TLSInformation:
    """A component of charm state containing information about TLS.

    Attributes:
        hostnames: Configured external hostname.
        tls_cert_and_ca_chain: A dict of
            hostname -> certificate obtained from the relation and the Certificate chain.
        private_key: Private key used to generate the CSR.
    """

    hostnames: list[str]
    tls_cert_and_ca_chain: dict[str, tuple[Certificate, list[Certificate]]]
    private_key: str

    @classmethod
    def from_charm(
        cls,
        charm: ops.CharmBase,
        certificates: TLSCertificatesRequiresV4,
        allow_no_certificates: bool = False,
    ) -> "TLSInformation":
        """Get TLS information from a charm instance.

        Args:
            charm: The haproxy charm.
            certificates: TLS certificates requirer class.
            allow_no_certificates: If the charm can proceed without requesting any certificates.

        Raises:
            PrivateKeyNotGeneratedError: When waiting for the private key to be generated.

        Returns:
            TLSInformation: Information about configured TLS certs.
        """
        cls.validate(charm, certificates, allow_no_certificates)

        hostnames = [
            certificate_request.common_name
            for certificate_request in certificates.certificate_requests
        ]
        tls_cert_and_ca_chain = {}

        provider_certificates, private_key = certificates.get_assigned_certificates()
        if not private_key:
            raise PrivateKeyNotGeneratedError("Waiting for private key creation")

        for provider_certificate in provider_certificates:
            hostname = provider_certificate.certificate.common_name
            tls_cert_and_ca_chain[hostname] = (
                provider_certificate.certificate,
                provider_certificate.chain,
            )

        return cls(
            hostnames=hostnames,
            tls_cert_and_ca_chain=tls_cert_and_ca_chain,
            private_key=str(private_key),
        )

    # Validation is done in this method instead of using a pydantic model because
    # there are cases where we need to validate the state but we don't need the state instance.
    @classmethod
    def validate(
        cls,
        charm: ops.CharmBase,
        certificates: TLSCertificatesRequiresV4,
        allow_no_certificates: bool = False,
    ) -> None:
        """Validate the precondition to initialize this state component.

        Args:
            charm: The haproxy charm.
            certificates: TLS certificates requirer class.
            allow_no_certificates: If the charm can proceed without requesting any certificates.

        Raises:
            TLSNotReadyError: if the charm is not ready to handle TLS.
        """
        tls_requirer_integration = charm.model.get_relation(certificates.relationship_name)
        if allow_no_certificates:
            logger.warning("Allowing load balancing without requesting TLS certificates.")

        if not certificates.certificate_requests and not allow_no_certificates:
            logger.error("The charm did not request any certificates.")
            raise TLSNotReadyError("The charm did not request any certificates.")

        if invalid_hostname := [
            certificate_request.common_name
            for certificate_request in certificates.certificate_requests
            if not re.match(HOSTNAME_REGEX, certificate_request.common_name)
        ]:
            logger.error(
                "Some requested hostname(s) (%s) does not match regex: %s",
                ",".join(invalid_hostname),
                HOSTNAME_REGEX,
            )
            raise TLSNotReadyError("Some requested hostname(s) are invalid.")

        if (
            tls_requirer_integration is None
            or tls_requirer_integration.data.get(charm.app) is None
        ):
            logger.error("Relation or relation data not ready.")
            raise TLSNotReadyError("Certificates relation or relation data not ready.")
